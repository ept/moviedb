Start by downloading the data files:

    $ wget -l 1 -r ftp://ftp.fu-berlin.de/pub/misc/movies/database/

Put the downloaded `*.list.gz` files in the `lists` subdirectory of this repository. Then compile
the source and parse the list files with the following commands:

    $ make all
    $ etc/mkdb -movie   # Movies

    # Filmographies (NO_OF_FILMOGRAPHY_LISTS):
    $ etc/mkdb -acr     # Actors
    $ etc/mkdb -acs     # Actresses
    $ etc/mkdb -cine    # Cinematographers
    $ etc/mkdb -comp    # Composers
    $ etc/mkdb -dir     # Directors
    $ etc/mkdb -write   # Writers
    $ etc/mkdb -edit    # Editors
    $ etc/mkdb -prodes  # Production Designers
    $ etc/mkdb -costdes # Costume Designers
    $ etc/mkdb -prdcr   # Producers
    $ etc/mkdb -misc    # Miscellaneous

    # Title info (NO_OF_TITLE_INFO_LISTS):
    $ etc/mkdb -time    # Running Times
    $ etc/mkdb -cert    # Certificates
    $ etc/mkdb -genre   # Genres
    $ etc/mkdb -keyword # Keywords
    $ etc/mkdb -prodco  # Production Company
    $ etc/mkdb -dist    # Distributors
    $ etc/mkdb -color   # Color Information
    $ etc/mkdb -mix     # Sound Mix
    $ etc/mkdb -cntry   # Country
    $ etc/mkdb -rel     # Release Dates
    $ etc/mkdb -loc     # Locations
    $ etc/mkdb -tech    # Technical
    $ etc/mkdb -lang    # Languages
    $ etc/mkdb -sfxco   # Special Effects Company

    $ etc/mkdb -aka     # Aka Titles -- FIXME currently broken
    $ etc/mkdb -naka    # Aka Names -- FIXME currently broken
    $ etc/mkdb -plot    # Plot Summaries
    $ etc/mkdb -bio     # Biographies -- FIXME currently broken
    $ etc/mkdb -crazy   # Crazy Credits
    $ etc/mkdb -goof    # Goofs
    $ etc/mkdb -quote   # Quotes
    $ etc/mkdb -triv    # Trivia
    $ etc/mkdb -mrr     # Movie Ratings -- FIXME currently broken
    $ etc/mkdb -lit     # Literature -- FIXME currently broken
    $ etc/mkdb -link    # Movie Links
    $ etc/mkdb -tag     # Tag Lines
    $ etc/mkdb -castcom # Cast Completion
    $ etc/mkdb -crewcom # Crew Completion
    $ etc/mkdb -vers    # Alternate Versions
    $ etc/mkdb -bus     # Business -- FIXME currently broken
    $ etc/mkdb -ld      # LaserDisc
    $ etc/mkdb -create

It writes parsed output to the `dbs` subdirectory. Next, we can import that data into Postgres for
further processing. With Postgres running locally, run the following in `psql`:

    create table titles (id int, title text not null, hexid text);
    copy titles (title, hexid) from '/absolute/path/to/dbs/titles.key' (format text, delimiter '|', encoding 'iso-8859-1');
    update titles set id = ('x' || lpad(hexid, 8, '0'))::bit(32)::int;
    alter table titles add primary key (id);
    alter table titles drop column hexid;

    create table names (id int, name text not null, hexid text);
    copy names (name, hexid) from '/absolute/path/to/dbs/names.key' (format text, delimiter '|', encoding 'iso-8859-1');
    update names set id = ('x' || lpad(hexid, 8, '0'))::bit(32)::int;
    alter table names add primary key (id);
    alter table names drop column hexid;

    create table attributes (id int, attribute text not null, hexid text);
    copy attributes (attribute, hexid) from '/absolute/path/to/dbs/attributes.key' (format text, delimiter '|', encoding 'iso-8859-1');
    update attributes set id = ('x' || lpad(hexid, 8, '0'))::bit(32)::int;
    alter table attributes add primary key (id);
    alter table attributes drop column hexid;

    create table movies_raw (id int not null, year_from int, year_to int, attr_id int);
    copy movies_raw (id, year_from, year_to, attr_id) from '/absolute/path/to/dbs/movies.tsv';
    -- A few duplicates are introduced by having multiple titles that differ only in case.
    -- Remove duplicates, keeping one of them arbitrarily:
    delete from movies_raw where ctid in (select m1.ctid from movies_raw m1 join movies_raw m2 on m1.id = m2.id and m1.ctid < m2.ctid);
    alter table movies_raw add primary key (id);
    update movies_raw set year_from = null where year_from = 0;
    update movies_raw set year_to = null where year_to = 0;
    update movies_raw set attr_id = null where attr_id = x'00ffffff'::int;

    create table movies (id int primary key, title text not null, series_id int, is_series boolean not null default 'false', properties jsonb not null);

    -- Find all episodes of series, whose title has the form: "Series Title" (year) {Episode Title}
    insert into movies (id, title, series_id, properties) (
        select episodes.id, episode[3], series.id,
            jsonb_strip_nulls(jsonb_build_object(
                'year', raw.year_from, 'year_to', raw.year_to, 'info', attribute,
                'suspended', case when episode[4] = ' {{SUSPENDED}}' then true else null end
            ))
        from (
            select id, regexp_matches(title, '^"(.*)" (\([^\)]+\)) \{([^\{\}]*)\}( \{\{SUSPENDED\}\})?$') as episode from titles
        ) episodes
        join titles series on series.title = '"' || episode[1] || '" ' || episode[2] || coalesce(episode[4], '')
        left join movies_raw raw on raw.id = episodes.id
        left join attributes on attributes.id = raw.attr_id
    );

    -- Special case: episodes marked suspended, where the series was not suspended
    -- (Trying to make this part of the previous query makes it run incredibly slow)
    insert into movies (id, title, series_id, properties) (
        select episodes.id, episode[3], series.id,
            jsonb_strip_nulls(jsonb_build_object(
                'year', raw.year_from, 'year_to', raw.year_to,
                'info', attribute, 'suspended', true
            ))
        from (
            select id, regexp_matches(title, '^"(.*)" (\([^\)]+\)) \{([^\{\}]*)\} \{\{SUSPENDED\}\}$') as episode from titles
        ) episodes
        join titles series on series.title = '"' || episode[1] || '" ' || episode[2]
        left join movies_raw raw on raw.id = episodes.id
        left join attributes on attributes.id = raw.attr_id
        left join movies existing on existing.id = episodes.id
        where existing.id is null
    );

    -- Find all series
    insert into movies (id, title, is_series, properties) (
        select series.id, title_parts[1] || ' ' || title_parts[2], 'true',
            jsonb_strip_nulls(jsonb_build_object(
                'year', year_from, 'year_to', year_to, 'info', attribute,
                'suspended', case when title_parts[3] = ' {{SUSPENDED}}' then true else null end
            ))
        from (
            select id, regexp_matches(title, '^"(.*)" (\([^\)]+\))( \{\{SUSPENDED\}\})?$') as title_parts from titles
        ) series
        left join movies_raw raw on raw.id = series.id
        left join attributes on attributes.id = raw.attr_id
    );

    -- Movies (neither series nor episodes)
    insert into movies (id, title, properties) (
        select movs.id, title_parts[1],
            jsonb_strip_nulls(jsonb_build_object(
                'year', year_from, 'year_to', year_to, 'info', attribute,
                'suspended', case when title_parts[2] = ' {{SUSPENDED}}' then true else null end
            ))
        from (
            select id, regexp_matches(title, '^([^"](?:[^\{]|\{[^\{])*)( \{\{SUSPENDED\}\})?$') as title_parts from titles
        ) movs
        left join movies_raw raw on raw.id = movs.id
        left join attributes on attributes.id = raw.attr_id
    );

    alter table movies add foreign key (series_id) references movies (id);


    create table actors               (name_id int not null, title_id int not null, attr_id int, character text, position int);
    create table actresses            (name_id int not null, title_id int not null, attr_id int, character text, position int);
    create table cinematographers     (name_id int not null, title_id int not null, attr_id int);
    create table composers            (name_id int not null, title_id int not null, attr_id int);
    create table costume_designers    (name_id int not null, title_id int not null, attr_id int);
    create table directors            (name_id int not null, title_id int not null, attr_id int);
    create table editors              (name_id int not null, title_id int not null, attr_id int);
    create table miscellaneous        (name_id int not null, title_id int not null, attr_id int);
    create table producers            (name_id int not null, title_id int not null, attr_id int);
    create table production_designers (name_id int not null, title_id int not null, attr_id int);
    create table writers              (name_id int not null, title_id int not null, attr_id int, line_order int, group_order int, subgroup_order int);
    copy actors               from '/absolute/path/to/dbs/actors.tsv'    (format text, encoding 'iso-8859-1');
    copy actresses            from '/absolute/path/to/dbs/actresses.tsv' (format text, encoding 'iso-8859-1');
    copy cinematographers     from '/absolute/path/to/dbs/cinematographers.tsv';
    copy composers            from '/absolute/path/to/dbs/composers.tsv';
    copy costume_designers    from '/absolute/path/to/dbs/costume-designers.tsv';
    copy directors            from '/absolute/path/to/dbs/directors.tsv';
    copy editors              from '/absolute/path/to/dbs/editors.tsv';
    copy miscellaneous        from '/absolute/path/to/dbs/miscellaneous.tsv';
    copy producers            from '/absolute/path/to/dbs/producers.tsv';
    copy production_designers from '/absolute/path/to/dbs/production-designers.tsv';
    copy writers              from '/absolute/path/to/dbs/writers.tsv';

    update actors    set position = null where position = 0;
    update actresses set position = null where position = 0;

    create table people (id int primary key, name text not null, properties jsonb not null);
    insert into people (select name_id, name, json_build_object('gender', 'male')   from actors    join names on name_id = names.id);
    insert into people (select name_id, name, json_build_object('gender', 'female') from actresses join names on name_id = names.id) on conflict do nothing;
    insert into people (select id, name, '{}'::jsonb from names) on conflict do nothing;

    create type credit_type as enum ('actor', 'cinematographer', 'composer', 'costume_designer', 'director', 'editor', 'miscellaneous', 'producer', 'production_designer', 'writer');

    create table credits (person_id int not null, movie_id int not null, type credit_type not null, properties jsonb not null);

    insert into credits (
        select name_id, title_id, 'actor',
            jsonb_strip_nulls(jsonb_build_object('info', attribute, 'character', character, 'position', position))
        from actors
        left join attributes on attributes.id = attr_id
    );

    insert into credits (
        select name_id, title_id, 'actor',
            jsonb_strip_nulls(jsonb_build_object('info', attribute, 'character', character, 'position', position))
        from actresses
        left join attributes on attributes.id = attr_id
    );

    insert into credits (
        select name_id, title_id, 'cinematographer',
            jsonb_strip_nulls(jsonb_build_object('info', attribute))
        from cinematographers
        left join attributes on attributes.id = attr_id
    );

    insert into credits (
        select name_id, title_id, 'composer',
            jsonb_strip_nulls(jsonb_build_object('info', attribute))
        from composers
        left join attributes on attributes.id = attr_id
    );

    insert into credits (
        select name_id, title_id, 'costume_designer',
            jsonb_strip_nulls(jsonb_build_object('info', attribute))
        from costume_designers
        left join attributes on attributes.id = attr_id
    );

    insert into credits (
        select name_id, title_id, 'director',
            jsonb_strip_nulls(jsonb_build_object('info', attribute))
        from directors
        left join attributes on attributes.id = attr_id
    );

    insert into credits (
        select name_id, title_id, 'editor',
            jsonb_strip_nulls(jsonb_build_object('info', attribute))
        from editors
        left join attributes on attributes.id = attr_id
    );

    insert into credits (
        select name_id, title_id, 'miscellaneous',
            jsonb_strip_nulls(jsonb_build_object('info', attribute))
        from miscellaneous
        left join attributes on attributes.id = attr_id
    );

    insert into credits (
        select name_id, title_id, 'producer',
            jsonb_strip_nulls(jsonb_build_object('info', attribute))
        from producers
        left join attributes on attributes.id = attr_id
    );

    insert into credits (
        select name_id, title_id, 'production_designer',
            jsonb_strip_nulls(jsonb_build_object('info', attribute))
        from production_designers
        left join attributes on attributes.id = attr_id
    );

    insert into credits (
        select name_id, title_id, 'writer',
            jsonb_strip_nulls(jsonb_build_object(
                'info', attribute, 'line_order', line_order,
                'group_order', group_order, 'subgroup_order', subgroup_order))
        from writers
        left join attributes on attributes.id = attr_id
    );

    -- If the same person appears in the same type of credit several times in the same movie,
    -- delete all but one occurrence arbitrarily. TODO perhaps it would be better to merge them.
    delete from credits where ctid in (
        select c1.ctid
        from credits c1
        join credits c2
            on c1.person_id = c2.person_id
            and c1.movie_id = c2.movie_id
            and c1.type = c2.type
            and c1.ctid < c2.ctid
    );

    alter table credits add foreign key (person_id) references people (id);
    alter table credits add foreign key (movie_id) references movies (id);
    create unique index on credits (person_id, movie_id, type);
    create index on credits (movie_id);

    create table certificates              (title_id int not null, value text not null, attr_id int);
    create table color_info                (title_id int not null, value text not null, attr_id int);
    create table countries                 (title_id int not null, value text not null, attr_id int);
    create table distributors              (title_id int not null, value text not null, attr_id int);
    create table genres                    (title_id int not null, value text not null, attr_id int);
    create table keywords                  (title_id int not null, value text not null, attr_id int);
    create table language                  (title_id int not null, value text not null, attr_id int);
    create table locations                 (title_id int not null, value text not null, attr_id int);
    create table production_companies      (title_id int not null, value text not null, attr_id int);
    create table release_dates             (title_id int not null, value text not null, attr_id int);
    create table running_times             (title_id int not null, value text not null, attr_id int);
    create table sound_mix                 (title_id int not null, value text not null, attr_id int);
    create table special_effects_companies (title_id int not null, value text not null, attr_id int);
    create table technical                 (title_id int not null, value text not null, attr_id int);

    copy certificates              from '/path/to/absolute/dbs/certificates.tsv'              (format text, encoding 'iso-8859-1');
    copy color_info                from '/path/to/absolute/dbs/color-info.tsv'                (format text, encoding 'iso-8859-1');
    copy countries                 from '/path/to/absolute/dbs/countries.tsv'                 (format text, encoding 'iso-8859-1');
    copy distributors              from '/path/to/absolute/dbs/distributors.tsv'              (format text, encoding 'iso-8859-1');
    copy genres                    from '/path/to/absolute/dbs/genres.tsv'                    (format text, encoding 'iso-8859-1');
    copy keywords                  from '/path/to/absolute/dbs/keywords.tsv'                  (format text, encoding 'iso-8859-1');
    copy language                  from '/path/to/absolute/dbs/language.tsv'                  (format text, encoding 'iso-8859-1');
    copy locations                 from '/path/to/absolute/dbs/locations.tsv'                 (format text, encoding 'iso-8859-1');
    copy production_companies      from '/path/to/absolute/dbs/production-companies.tsv'      (format text, encoding 'iso-8859-1');
    copy release_dates             from '/path/to/absolute/dbs/release-dates.tsv'             (format text, encoding 'iso-8859-1');
    copy running_times             from '/path/to/absolute/dbs/running-times.tsv'             (format text, encoding 'iso-8859-1');
    copy sound_mix                 from '/path/to/absolute/dbs/sound-mix.tsv'                 (format text, encoding 'iso-8859-1');
    copy special_effects_companies from '/path/to/absolute/dbs/special-effects-companies.tsv' (format text, encoding 'iso-8859-1');
    copy technical                 from '/path/to/absolute/dbs/technical.tsv'                 (format text, encoding 'iso-8859-1');


    create table movies_doc (id int primary key, title text not null, series_id int, is_series boolean not null, properties jsonb not null);

    insert into movies_doc
    select movies.id as id, title, series_id, is_series,
        jsonb_strip_nulls(jsonb_build_object(
            'year', properties->'year',
            'year_to', properties->'year_to',
            'info', properties->'info',
            'suspended', properties->'suspended',
            'certificates', certificate_arr,
            'color_info', color_info_arr,
            'countries', country_arr,
            'distributors', distributor_arr,
            'genres', genre_arr,
            'keywords', keyword_arr,
            'language', language_arr,
            'locations', location_arr,
            'prod_companies', prodco_arr,
            'release_dates', reldate_arr,
            'running_times', runtime_arr,
            'sound_mix', sound_mix_arr,
            'sfx_companies', sfxco_arr,
            'technical', technical_arr)) as properties
    from movies
    left join (
        select title_id, array_to_json(array_agg(value))::jsonb as country_arr from countries group by title_id
    ) countries2 on countries2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(value))::jsonb as genre_arr from genres group by title_id
    ) genres2 on genres2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(value))::jsonb as keyword_arr from keywords group by title_id
    ) keywords2 on keywords2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(jsonb_strip_nulls(jsonb_build_object(
            'certificate', value, 'note', attribute))))::jsonb as certificate_arr
        from certificates
        left join attributes on attributes.id = attr_id group by title_id
    ) certificates2 on certificates2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(jsonb_strip_nulls(jsonb_build_object(
            'color_info', value, 'note', attribute))))::jsonb as color_info_arr
        from color_info
        left join attributes on attributes.id = attr_id group by title_id
    ) color_info2 on color_info2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(jsonb_strip_nulls(jsonb_build_object(
            'company', value, 'note', attribute))))::jsonb as distributor_arr
        from distributors
        left join attributes on attributes.id = attr_id group by title_id
    ) distributors2 on distributors2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(jsonb_strip_nulls(jsonb_build_object(
            'language', value, 'note', attribute))))::jsonb as language_arr
        from language
        left join attributes on attributes.id = attr_id group by title_id
    ) language2 on language2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(jsonb_strip_nulls(jsonb_build_object(
            'location', value, 'note', attribute))))::jsonb as location_arr
        from locations
        left join attributes on attributes.id = attr_id group by title_id
    ) locations2 on locations2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(jsonb_strip_nulls(jsonb_build_object(
            'company', value, 'note', attribute))))::jsonb as prodco_arr
        from production_companies
        left join attributes on attributes.id = attr_id group by title_id
    ) prodco2 on prodco2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(jsonb_strip_nulls(jsonb_build_object(
            'release_date', value, 'note', attribute))))::jsonb as reldate_arr
        from release_dates
        left join attributes on attributes.id = attr_id group by title_id
    ) release_dates2 on release_dates2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(jsonb_strip_nulls(jsonb_build_object(
            'running_time', value, 'note', attribute))))::jsonb as runtime_arr
        from running_times
        left join attributes on attributes.id = attr_id group by title_id
    ) running_times2 on running_times2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(jsonb_strip_nulls(jsonb_build_object(
            'company', value, 'note', attribute))))::jsonb as sound_mix_arr
        from sound_mix
        left join attributes on attributes.id = attr_id group by title_id
    ) sound_mix2 on sound_mix2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(jsonb_strip_nulls(jsonb_build_object(
            'company', value, 'note', attribute))))::jsonb as sfxco_arr
        from special_effects_companies
        left join attributes on attributes.id = attr_id group by title_id
    ) sfxco2 on sfxco2.title_id = movies.id
    left join (
        select title_id, array_to_json(array_agg(jsonb_strip_nulls(jsonb_build_object(
            'info', value, 'note', attribute))))::jsonb as technical_arr
        from technical
        left join attributes on attributes.id = attr_id group by title_id
    ) technical2 on technical2.title_id = movies.id;
